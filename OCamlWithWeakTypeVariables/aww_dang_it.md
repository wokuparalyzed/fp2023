Темы (окончательные) к экзамену по ФП 2023-2024


Вопросы-автоматы на оценку F обозначены ‡. 

1. Функции в программировании и функции в математике. Сходства и отличия. ‡ Понятие чистой функции 
1. ‡ Алгебраические типы данных. Что такое и в чем их алгебраичность?
   * Boolean blindness
1. ‡ Хвостовая рекурсия. Уметь объяснять, чем хвостовая лучше обычной обычной рекурсии примерах. CPS
   * Переход к хвостовой рекурсии. (Переписать функцию, что дал экзаменатор)
1. Continuation passing style. Преобразование функций из стандартного (direct) стиля в CPS
   * ‡ Быть готовыми переписать функцию в CPS (функция выбирается экзаменатором)
1. Лямбда-исчисление
   * ‡ Привести (подготовить заранее) трассу вычисления факториала (или фибоначчи) для каждой из стратегий 
     (CBN, CBV, NO, AO) для "голого" лямбда исчисления. (Функцию и стратегию выбирает экзаменатор.) 
     Демонстрировать понимание того, как проходят редукции в указанной стратегии
   * Понятие исчисления. Аксиомы, правила вывода, посылки и заключения. Доказательства
   * ‡ Определение языка лямбда-выражений. Три правила (α, β, η) преобразования лямбда-выражений.
   * Лямбда исчисление как универсальный язык программирования. Числа Чёрча, арифметика, ветвления
   * Редексы. Стратегии вычисления лямбда-термов: CBN, CBV, CBNeeded, NO, AO. Достоинства и недостатки
   * Написание рекурсивных функций без использования рекурсии. Комбинаторы неподвижной точки для разных стратегий. Примеры
   * Проблема останова
   * Capture avoiding substitution. Индексы и уровни де Брёйна
   * SKI
1. ‡ Определение монады. Стандартные монады: Maybe/Option, Result, List, Identity, Parser, Concurrency.
   * Как в использовании отличаются монады и исключения?
1. Аппликативные функторы. Чем отличаются от монад, и когда их стоит предпочитать монадам?
1. Парсер-комбинаторы.
   * ‡ Пример: синтаксический анализатор языка a^n b^n c^n (где а,b,c -- символы алфавита, ^n -- n вхождений подряд).
     Плохой вход должен детектироваться максимально рано.
1. Унификация и подстановки. Occurs check.
   * Уметь демонстрировать преимущества и недостатки включения/выключения occurs check.
   * ‡ Уметь проунифицировать на примере экзаменатора.
1. ‡ STLC. Понятие схемы типов.
1. Вывод типов в системе Хиндли-Милнера. Правила, которые отличают от STLC.
1. ‡ Понятие мемоизации
   * Пример: эффективное вычисление чисел Фибоначчи
1. Ленивые списки (потоки)
   * Стандартные задачи: фибоначчи
1. PFDS. ‡ Понятие неизменяемых и устойчивых (persistent) типов данных.
1. PFDS. Чисто функциональные очереди. Три реализации и их асимптотики.
1. PFDS. Понятие префиксных деревьев и HAMT.
1. Схемы рекурсии. На примере списков и деревьев. Ката- и анаморфизмы.
1. Схемы рекурсии. Хиломорфизм. Решения задач: фибоначчи, binary partition, LCS, merge sort. 
   * ‡ Идея реализации динамического программирования через схемы рекурсии


<!--
1. Четыре вида полиморфизма ([согласно Л. Карделли](https://www.classes.cs.uchicago.edu/archive/2012/spring/22300-1/papers/Cardelli-Wegner.pdf))
1. История Mars Climate Orbiter (летучка 3). Понятия: zero-cost abstraction, leaking abstraction.
1. GADT, что такое и зачем нужно
   * Равенство  типов (летучка 4)
   * Использование для форматированной печати
1. Три вида тестов в инфраструктуре
1. виды семантик (операционная/денотационная и большого/малого шага)
-->




# ФП 2023. Репо для домашек

Домашки по курсу ФП 2023 оформлять **в виде пулл-реквестов к этому репо**.

Учебная группа имеет чатик в мессенджере. Все вопросы писать туду. В личку писать нельзя -- буду банить.

В директории `/Lambda` лежит шаблон-скелет, его нужно скопипастить и исправить под свои нужды:
- Указать автора (я должен быть способен сопоставить решение с фамилией в ведомости)
- Переименовать проект под свой мини-язык и пересобрать dune'ой. CI при сборке ожидает имя проекта, совпадающее с именем директории. **И так как имя проекта это `[a-zA-Z_]+`, то у директорий с пробелами и символами `#` шансов пройти CI нет**
- Cделать реализацию. Разработку рекомендуется вести итеративной моделью, а не водопадной.
- Изменять или удалять шаблон `Lambda` нельзя.

Ожидается примерно следующая структура репозитория
- `/Lambda` -- шаблон проекта домашки, который редактирует только препод (вам необходимо будет его скопировать и переименовать, редактировать нельзя, удалившим его буду ставить минус баллы);
- `/CSharpExc` -- реализация мини-С# c исключениями, на основе шаблона `/Lambda`;
- `/Java` -- реализация мини-Java, снова на основе шаблона `/Lambda`;
- и т.д.

Для Merge Requests (a.k.a. pull requests) настроен CI, который смотрит *в какой директории* (проекте) *произошли последние изменения*,
*и именно в этой директории запускает сборку и тесты*.
Например, если поменялся файл `Lambda/src/Parser.ml`, то запустятся все тесты из директории проекта `Lambda`,
а тесты из проекта `Java` запускаться не будут.


Также CI собирает документацию к миниязыку и выкладывает её в https://kakadu.github.io/fp2023/doc/LANGUAGE (например, [вот так](https://kakadu.github.io/fp2023/doc/Lambda)). А ещё измеряется покрытие тестами (например, [так](https://kakadu.github.io/fp2023/cov/Lambda)).

###### N.B. Не удаляйте директорию Lambda. Это шаблон!

### Приёмка задач

Решения принимаются в виде пулл-реквестов к этому репо.
* Пулл-реквесты должны проходить CI
  * в том числе линтер (замечания должны исправляться);
  * проверку, что автоформатирование через ocamlformat настроено и соблюдается;
  * [DCO](https://github.com/apps/dco);
* В названии надо указать задачу, которую реализовывали, идентифицировать себя (фамилия, имя и курс, если возможны неоднозначности).
* К дереву абстрактного синтаксиса (AST) должны быть написаны комменты, какой конструтор за что отвечает. (Например, [как здесь](https://github.com/ocaml/ocaml/blob/4.14/parsing/parsetree.mli#L323).)
* Да, объекты и присваивание запрещены.

Тесты нужны, чтобы убедить преподавателя, что вы таки запускали свою поделку на адекватных примерах.
Большинство тестов будут интеграционные: запустил самописный интерпретатор миниязыка и сравнил с результатом (например, с поведением интерпретатора оригинального языка).
В CI измеряeтся тестовое покрытие в процентах. Чем больше покрытие --- тем лучше.
Если код не вызывается в тестах, то либо он не нужен, либо на него не написан тест, либо (в редких случаях) это бага `ppx_bisect`, который измеряет покрытие. Чтобы покрытие тестами таки считалось, не забывайте приписывать к своим библиотекам/исполняемым файлом заклинание в dune-файлах:

    (instrumentation
      (backend bisect_ppx))

### Подготовка окружения

Далее инструкции по найстройки всего под GNU/Linux. Но на Windows+WSL2 тоже должно работать.

Во-первых, нужен пакетный менеджер opam версии 2.х. С помощью него будем устанавливать OCaml 4.14.1 и необходимые пакеты.
Системный OCaml (установленный, например, из репозиториев Ubuntu) использовать не рекомендуется.

После установки opam следует его проинициализировать и установить правильный компилятор (у меня обычно вместо SWITCHNAME используется `4.14.1+flambda`)

Для opam >= 2.1:

    opam init --bare
    opam update
    opam switch create SWITCHNAME --packages=ocaml-variants.4.14.1+options,ocaml-option-flambda --yes

Перед этим можно удалить другие switch'и, если они есть, с помощью команды `opam switch remove SWITCHNAME`.

После установки у вас будет рабочий компилятор по-умолчанию в директории `~/.opam/SWITCHNAME/bin`. В конце установки opam вам предложит что-то добавить в ~/.bashrc, чтобы пути к компилятору автоматически подхватывались. Рекомендую это сделать.

Если что-то пошло не так, то всегда можно указать нужный свитч руками командой, например:

    export OPAMSWITCH=SWITCHNAME && eval $(opam env)

и затем убедиться, что путь до компилятора правильный

    $ which ocamlc
    /home/username/.opam/SWITCHNAME/bin/ocamlc

Замечание. Когда вы будете запускать VsCode, то информация об  окружении opam из файла ~/.bashrc автоматически применяться не будет, потому что так это работает в UNIX системах из покон веков. Рекомендуется, либо запускать VsCode из-под opam командой `opam exec -- code`, либо прописать в месте запуска правильную переменную среды OPAMSWITCH, и запускать opam через sh: `sh -c 'eval $(opam env) && code'`

Когда VsCode запустится, её плагин https://marketplace.visualstudio.com/items?itemName=ocamllabs.ocaml-platform слева снизу должен показать, что правильная версия компилятора подцепилась.

В процессе работы вам также понадобится автоформаттер кода. Он устанавливается с помощью `opam install ocamlformat` в

     $ which ocamlformat
     /home/username/.opam/SWITCHNAME/bin/ocamlformat

Необходимо также в VsCode включить автоформатирование: Settings->Text Editor->Formatting->Format On Paste и Format on Save.
